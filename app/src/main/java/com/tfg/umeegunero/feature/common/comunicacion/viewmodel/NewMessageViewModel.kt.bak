package com.tfg.umeegunero.feature.common.comunicacion.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.Timestamp
import com.tfg.umeegunero.data.repository.AuthRepository
import com.tfg.umeegunero.data.repository.UsuarioRepository
import com.tfg.umeegunero.feature.common.comunicacion.model.MessagePriority
import com.tfg.umeegunero.feature.common.comunicacion.model.MessageStatus
import com.tfg.umeegunero.feature.common.comunicacion.model.MessageType
import com.tfg.umeegunero.feature.common.comunicacion.model.RecipientItem
import com.tfg.umeegunero.feature.common.comunicacion.model.UnifiedMessage
import com.tfg.umeegunero.feature.common.comunicacion.model.UnifiedMessageRepository
import com.tfg.umeegunero.util.Result
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import timber.log.Timber
import java.util.UUID
import javax.inject.Inject

/**
 * Estructura para representar a un destinatario seleccionado
 */
data class ReceiverInfo(
    val id: String,
    val name: String
)

/**
 * Estructura para representar resultados de búsqueda de usuarios
 */
data class UserSearchResult(
    val id: String,
    val name: String,
    val userType: String
)

/**
 * Estructura para representar un grupo de destinatarios
 */
data class RecipientGroup(
    val id: String,
    val name: String,
    val type: RecipientGroupType
)

/**
 * Tipos de grupos de destinatarios
 */
enum class RecipientGroupType {
    CENTER,        // Todo un centro educativo
    COURSE,        // Un curso completo
    CLASS,         // Una clase específica
    TEACHER,       // Todos los profesores
    PARENT,        // Todos los padres/tutores
    USER           // Usuario individual
}

/**
 * Estado de la UI para la pantalla de nuevo mensaje
 */
data class NewMessageUiState(
    val recipientId: String = "",
    val recipients: List<RecipientItem> = emptyList(),
    val recipientGroups: List<RecipientGroup> = emptyList(), // Grupos de destinatarios
    val availableCenters: List<RecipientGroup> = emptyList(),
    val availableCourses: List<RecipientGroup> = emptyList(),
    val availableClasses: List<RecipientGroup> = emptyList(),
    val showGroupSelection: Boolean = false, // Controla la visibilidad del selector de grupos
    val selectedGroupType: RecipientGroupType? = null, // Tipo de grupo seleccionado
    val searchResults: List<RecipientItem> = emptyList(),
    val subject: String = "",
    val content: String = "",
    val messageType: MessageType = MessageType.CHAT,
    val priority: MessagePriority = MessagePriority.NORMAL,
    val conversationId: String = "",
    val replyingTo: UnifiedMessage? = null,
    val attachments: List<Map<String, String>> = emptyList(),
    val isLoading: Boolean = false,
    val isSearching: Boolean = false,
    val isSent: Boolean = false,
    val error: String? = null,
    val conversationStarted: Boolean = false,
    val searchQuery: String = "",
    val showTypeMenu: Boolean = false,
    val isReply: Boolean = false,
    val isSending: Boolean = false,
    val messageSent: Boolean = false,
    val titleError: String? = null,
    val contentError: String? = null
) {
    /**
     * Indica si el mensaje puede ser enviado (validación)
     */
    val canSendMessage: Boolean
        get() = subject.isNotBlank() && content.isNotBlank() && 
                (recipients.isNotEmpty() || recipientGroups.isNotEmpty() || replyingTo != null)
}

/**
 * ViewModel para la pantalla de creación de nuevo mensaje
 */
@HiltViewModel
class NewMessageViewModel @Inject constructor(
    private val messageRepository: UnifiedMessageRepository,
    private val usuarioRepository: UsuarioRepository,
    private val authRepository: AuthRepository,
    private val centroRepository: com.tfg.umeegunero.data.repository.CentroRepository,
    private val cursoRepository: com.tfg.umeegunero.data.repository.CursoRepository,
    private val claseRepository: com.tfg.umeegunero.data.repository.ClaseRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(NewMessageUiState())
    val uiState: StateFlow<NewMessageUiState> = _uiState.asStateFlow()
    
    init {
        // Cargar usuarios para la búsqueda
        searchUsers("")
        
        // Si el tipo de mensaje es ANNOUNCEMENT, cargar los centros, cursos y clases disponibles
        viewModelScope.launch {
            loadAvailableCenters()
        }
    }
    
    /**
     * Carga los centros disponibles para el usuario actual
     */
    private suspend fun loadAvailableCenters() {
        try {
            val currentUser = authRepository.getCurrentUser() ?: return
            
            when (val result = centroRepository.getAllCentros()) {
                is Result.Success -> {
                    val centers = result.data.map { centro ->
                        RecipientGroup(
                            id = centro.id,
                            name = centro.nombre,
                            type = RecipientGroupType.CENTER
                        )
                    }
                    _uiState.update { it.copy(availableCenters = centers) }
                }
                else -> Timber.d("No se pudo cargar la lista de centros")
            }
        } catch (e: Exception) {
            Timber.e(e, "Error al cargar centros")
        }
    }
    
    /**
     * Carga los cursos disponibles para un centro específico
     */
    fun loadCoursesForCenter(centerId: String) {
        viewModelScope.launch {
            try {
                when (val result = cursoRepository.getCursosPorCentro(centerId)) {
                    is Result.Success -> {
                        val courses = result.data.map { curso ->
                            RecipientGroup(
                                id = curso.id,
                                name = curso.nombre,
                                type = RecipientGroupType.COURSE
                            )
                        }
                        _uiState.update { it.copy(availableCourses = courses) }
                    }
                    else -> Timber.d("No se pudieron cargar los cursos del centro $centerId")
                }
            } catch (e: Exception) {
                Timber.e(e, "Error al cargar cursos del centro $centerId")
            }
        }
    }
    
    /**
     * Carga las clases disponibles para un curso específico
     */
    fun loadClassesForCourse(courseId: String) {
        viewModelScope.launch {
            try {
                when (val result = claseRepository.getClasesPorCurso(courseId)) {
                    is Result.Success -> {
                        val classes = result.data.map { clase ->
                            RecipientGroup(
                                id = clase.id,
                                name = clase.nombre,
                                type = RecipientGroupType.CLASS
                            )
                        }
                        _uiState.update { it.copy(availableClasses = classes) }
                    }
                    else -> Timber.d("No se pudieron cargar las clases del curso $courseId")
                }
            } catch (e: Exception) {
                Timber.e(e, "Error al cargar clases del curso $courseId")
            }
        }
    }
    
    /**
     * Actualiza el tipo de grupo seleccionado
     */
    fun selectGroupType(type: RecipientGroupType) {
        _uiState.update { it.copy(selectedGroupType = type) }
        
        // Si se selecciona un tipo de grupo, cargar los datos necesarios
        when (type) {
            RecipientGroupType.CENTER -> {
                // Los centros ya se cargan al iniciar
            }
            RecipientGroupType.TEACHER -> {
                // Mostrar todos los profesores
                viewModelScope.launch {
                    searchTeachers()
                }
            }
            RecipientGroupType.PARENT -> {
                // Mostrar todos los familiares
                viewModelScope.launch {
                    searchParents()
                }
            }
            else -> {
                // Para los demás tipos, esperamos la selección del usuario
            }
        }
    }
    
    /**
     * Busca todos los profesores
     */
    private suspend fun searchTeachers() {
        try {
            when (val result = usuarioRepository.buscarUsuariosPorPerfil("PROFESOR")) {
                is Result.Success -> {
                    val teachers = result.data.map { profesor ->
                        RecipientItem(
                            id = profesor.dni,
                            name = "${profesor.nombre} ${profesor.apellidos}",
                            email = profesor.email,
                            avatarUrl = null
                        )
                    }
                    _uiState.update { it.copy(searchResults = teachers) }
                }
                else -> Timber.d("No se pudieron cargar los profesores")
            }
        } catch (e: Exception) {
            Timber.e(e, "Error al cargar profesores")
        }
    }
    
    /**
     * Busca todos los padres/tutores
     */
    private suspend fun searchParents() {
        try {
            when (val result = usuarioRepository.buscarUsuariosPorPerfil("FAMILIAR")) {
                is Result.Success -> {
                    val parents = result.data.map { familiar ->
                        RecipientItem(
                            id = familiar.dni,
                            name = "${familiar.nombre} ${familiar.apellidos}",
                            email = familiar.email,
                            avatarUrl = null
                        )
                    }
                    _uiState.update { it.copy(searchResults = parents) }
                }
                else -> Timber.d("No se pudieron cargar los familiares")
            }
        } catch (e: Exception) {
            Timber.e(e, "Error al cargar familiares")
        }
    }
    
    /**
     * Añade un grupo de destinatarios
     */
    fun addRecipientGroup(group: RecipientGroup) {
        val currentGroups = _uiState.value.recipientGroups.toMutableList()
        if (currentGroups.none { it.id == group.id }) {
            currentGroups.add(group)
            _uiState.update { it.copy(recipientGroups = currentGroups) }
        }
    }
    
    /**
     * Elimina un grupo de destinatarios
     */
    fun removeRecipientGroup(groupId: String) {
        val currentGroups = _uiState.value.recipientGroups.toMutableList()
        currentGroups.removeAll { it.id == groupId }
        _uiState.update { it.copy(recipientGroups = currentGroups) }
    }
    
    /**
     * Alterna la visibilidad del selector de grupos
     */
    fun toggleGroupSelection() {
        _uiState.update { it.copy(showGroupSelection = !it.showGroupSelection) }
    }
    
    /**
     * Actualiza el título del mensaje
     */
    fun updateTitle(title: String) {
        _uiState.update { 
            it.copy(
                subject = title,
                titleError = if (title.isBlank()) "El título es obligatorio" else null
            )
        }
    }
    
    /**
     * Actualiza el contenido del mensaje
     */
    fun updateContent(content: String) {
        _uiState.update { 
            it.copy(
                content = content,
                contentError = if (content.isBlank()) "El contenido es obligatorio" else null
            )
        }
    }
    
    /**
     * Establece el tipo de mensaje
     */
    fun setMessageType(type: MessageType) {
        _uiState.update { it.copy(messageType = type) }
    }
    
    /**
     * Establece la prioridad del mensaje
     */
    fun updatePriority(priority: MessagePriority) {
        _uiState.update { it.copy(priority = priority) }
    }
    
    /**
     * Actualiza la consulta de búsqueda y busca usuarios
     */
    fun updateSearchQuery(query: String) {
        _uiState.update { it.copy(searchQuery = query) }
        searchUsers(query)
    }
    
    /**
     * Busca usuarios para agregar como destinatarios
     */
    fun searchUsers(query: String) {
        if (query.isBlank()) {
            _uiState.update { it.copy(searchResults = emptyList()) }
            return
        }
        
        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isSearching = true) }
                
                // Validar que tenemos un usuario actual
                val currentUser = authRepository.getCurrentUser() ?: return@launch
                
                // Implementar la búsqueda de usuarios
                val usuariosResult = usuarioRepository.buscarUsuariosPorNombreOCorreo(query, 10)
                
                if (usuariosResult is Result.Success) {
                    val usuariosFiltrados = usuariosResult.data.filter { it.dni != currentUser.dni }
                    _uiState.update { 
                        it.copy(
                            searchResults = usuariosFiltrados.map { usuario ->
                                RecipientItem(
                                    id = usuario.dni,
                                    name = "${usuario.nombre} ${usuario.apellidos}",
                                    email = usuario.email,
                                    avatarUrl = usuario.avatarUrl
                                )
                            },
                            isSearching = false
                        )
                    }
                } else {
                    _uiState.update { it.copy(
                        searchResults = emptyList(),
                        isSearching = false,
                        error = "Error al buscar usuarios"
                    )}
                }
            } catch (e: Exception) {
                Timber.e(e, "Error al buscar usuarios")
                _uiState.update { it.copy(
                    isSearching = false,
                    error = "Error al buscar usuarios: ${e.message}"
                )}
            }
        }
    }
    
    /**
     * Añade un destinatario a la lista de seleccionados
     */
    fun addReceiver(id: String, name: String) {
        val currentReceivers = _uiState.value.recipients.toMutableList()
        if (currentReceivers.none { it.id == id }) {
            currentReceivers.add(RecipientItem(id, name, "", ""))
            _uiState.update { it.copy(recipients = currentReceivers) }
        }
    }
    
    /**
     * Elimina un destinatario de la lista de seleccionados
     */
    fun removeReceiver(id: String) {
        val currentReceivers = _uiState.value.recipients.toMutableList()
        currentReceivers.removeAll { it.id == id }
        _uiState.update { it.copy(recipients = currentReceivers) }
    }
    
    /**
     * Carga un mensaje original para responder
     */
    fun loadOriginalMessage(messageId: String) {
        viewModelScope.launch {
            try {
                when (val result = messageRepository.getMessageById(messageId)) {
                    is Result.Success -> {
                        val originalMessage = result.data
                        _uiState.update { 
                            it.copy(
                                replyingTo = originalMessage,
                                isReply = true,
                                subject = if (!originalMessage.title.startsWith("RE: ")) 
                                    "RE: ${originalMessage.title}" else originalMessage.title,
                                recipients = listOf(
                                    RecipientItem(
                                        id = originalMessage.senderId,
                                        name = originalMessage.senderName,
                                        email = "",
                                        avatarUrl = ""
                                    )
                                ),
                                messageType = originalMessage.type
                            )
                        }
                    }
                    is Result.Error -> {
                        _uiState.update { 
                            it.copy(error = "Error al cargar mensaje original: ${result.message}")
                        }
                    }
                    is Result.Loading -> {
                        // No necesitamos manejar este estado aquí
                    }
                }
            } catch (e: Exception) {
                Timber.e(e, "Error al cargar mensaje original")
                _uiState.update { 
                    it.copy(error = "Error al cargar mensaje original: ${e.message}")
                }
            }
        }
    }
    
    /**
     * Establece un ID de destinatario preseleccionado
     */
    fun setReceiverId(receiverId: String) {
        viewModelScope.launch {
            try {
                val usuarioResult = usuarioRepository.getUsuarioById(receiverId)
                if (usuarioResult is Result.Success) {
                    val usuario = usuarioResult.data
                    addReceiver(usuario.dni, "${usuario.nombre} ${usuario.apellidos}")
                }
            } catch (e: Exception) {
                Timber.e(e, "Error al obtener destinatario: $receiverId")
            }
        }
    }
    
    /**
     * Alterna la visibilidad del menú de tipos de mensaje
     */
    fun toggleTypeMenu() {
        _uiState.update { it.copy(showTypeMenu = !it.showTypeMenu) }
    }
    
    /**
     * Limpia la información de respuesta
     */
    fun clearReplyTo() {
        _uiState.update { 
            it.copy(
                replyingTo = null,
                isReply = false
            )
        }
    }
    
    /**
     * Establece el mensaje al que se responde
     */
    fun setReplyTo(message: UnifiedMessage) {
        _uiState.update { currentState ->
            currentState.copy(
                replyingTo = message,
                subject = if (!message.title.startsWith("RE: ")) "RE: ${message.title}" else message.title,
                recipients = listOf(
                    RecipientItem(
                        id = message.senderId,
                        name = message.senderName,
                        email = "",
                        avatarUrl = null
                    )
                ),
                messageType = message.type,
                conversationId = message.conversationId
            )
        }
    }
    
    /**
     * Envía el mensaje
     */
    fun sendMessage() {
        val currentState = _uiState.value
        
        // Validar campos obligatorios
        if (currentState.subject.isBlank() || currentState.content.isBlank()) {
            _uiState.update {
                it.copy(
                    titleError = if (it.subject.isBlank()) "El título es obligatorio" else null,
                    contentError = if (it.content.isBlank()) "El contenido es obligatorio" else null
                )
            }
            return
        }
        
        // Validar destinatarios si no es una respuesta
        if (currentState.replyingTo == null && 
            currentState.recipients.isEmpty() && 
            currentState.recipientGroups.isEmpty()) {
            _uiState.update {
                it.copy(error = "Debe seleccionar al menos un destinatario o grupo")
            }
            return
        }
        
        _uiState.update { it.copy(isLoading = true, error = null, isSending = true) }
        
        viewModelScope.launch {
            try {
                // Obtener el usuario actual
                val currentUser = authRepository.getCurrentUser()
                if (currentUser == null) {
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            isSending = false,
                            error = "Error: Usuario no autenticado"
                        )
                    }
                    return@launch
                }
                
                // Expandir los grupos de destinatarios a usuarios individuales
                val expandedReceivers = mutableListOf<String>()
                
                // Añadir destinatarios individuales
                expandedReceivers.addAll(currentState.recipients.map { it.id })
                
                // Expandir grupos (centro, curso, clase, etc.)
                for (group in currentState.recipientGroups) {
                    when (group.type) {
                        RecipientGroupType.CENTER -> {
                            // Obtener todos los usuarios del centro
                            val usersResult = usuarioRepository.getUsuariosPorCentro(group.id)
                            if (usersResult is Result.Success) {
                                expandedReceivers.addAll(usersResult.data.map { it.dni })
                            }
                        }
                        RecipientGroupType.COURSE -> {
                            // Obtener todos los alumnos del curso
                            val alumnosResult = claseRepository.getAllAlumnosPorCurso(group.id)
                            if (alumnosResult is Result.Success) {
                                val alumnosIds = alumnosResult.data.map { it.dni }
                                expandedReceivers.addAll(alumnosIds)
                                
                                // Obtener los familiares de esos alumnos
                                for (alumnoId in alumnosIds) {
                                    val familiaresResult = usuarioRepository.getFamiliaresPorAlumnoId(alumnoId)
                                    if (familiaresResult is Result.Success) {
                                        expandedReceivers.addAll(familiaresResult.data.map { it.dni })
                                    }
                                }
                            }
                        }
                        RecipientGroupType.CLASS -> {
                            // Obtener todos los alumnos de la clase
                            val alumnosResult = claseRepository.getAlumnosPorClase(group.id)
                            if (alumnosResult is Result.Success) {
                                val alumnosIds = alumnosResult.data.map { it.dni }
                                expandedReceivers.addAll(alumnosIds)
                                
                                // Obtener los familiares de esos alumnos
                                for (alumnoId in alumnosIds) {
                                    val familiaresResult = usuarioRepository.getFamiliaresPorAlumnoId(alumnoId)
                                    if (familiaresResult is Result.Success) {
                                        expandedReceivers.addAll(familiaresResult.data.map { it.dni })
                                    }
                                }
                            }
                        }
                        RecipientGroupType.TEACHER -> {
                            // Obtener todos los profesores
                            val profesoresResult = usuarioRepository.buscarUsuariosPorPerfil("PROFESOR")
                            if (profesoresResult is Result.Success) {
                                expandedReceivers.addAll(profesoresResult.data.map { it.dni })
                            }
                        }
                        RecipientGroupType.PARENT -> {
                            // Obtener todos los familiares
                            val familiaresResult = usuarioRepository.buscarUsuariosPorPerfil("FAMILIAR")
                            if (familiaresResult is Result.Success) {
                                expandedReceivers.addAll(familiaresResult.data.map { it.dni })
                            }
                        }
                        RecipientGroupType.USER -> {
                            // Ya incluido en recipients
                        }
                    }
                }
                
                // Eliminar duplicados y el propio remitente
                val uniqueReceivers = expandedReceivers.distinct().filter { it != currentUser.dni }
                
                // Crear el mensaje
                val message = UnifiedMessage(
                    id = UUID.randomUUID().toString(),
                    title = currentState.subject,
                    content = currentState.content,
                    type = currentState.messageType,
                    priority = currentState.priority,
                    senderId = currentUser.dni,
                    senderName = "${currentUser.nombre} ${currentUser.apellidos}".trim(),
                    conversationId = currentState.conversationId,
                    replyToId = currentState.replyingTo?.id ?: "",
                    // Si es una respuesta, usar el remitente original como destinatario
                    receiverId = if (currentState.replyingTo != null) 
                                    currentState.replyingTo.senderId 
                                 else 
                                    if (uniqueReceivers.size == 1) 
                                        uniqueReceivers.first() 
                                    else "",
                    // Si hay múltiples destinatarios, usar la lista expandida
                    receiversIds = if (uniqueReceivers.size > 1) uniqueReceivers else emptyList(),
                    timestamp = Timestamp.now(),
                    status = MessageStatus.UNREAD
                )
                
                // Enviar el mensaje mediante el repositorio
                val result = messageRepository.sendMessage(message)
                
                when (result) {
                    is Result.Success -> {
                        // Mensaje enviado correctamente
                        Timber.d("Mensaje enviado correctamente con ID: ${result.data}")
                        
                        _uiState.update { 
                            it.copy(
                                isLoading = false,
                                isSending = false,
                                messageSent = true,
                                subject = "",
                                content = "",
                                recipients = emptyList(),
                                recipientGroups = emptyList(),
                                error = null
                            )
                        }
                    }
                    is Result.Error -> {
                        // Error al enviar el mensaje
                        Timber.e(result.exception, "Error al enviar mensaje: ${result.message}")
                        
                        _uiState.update { 
                            it.copy(
                                isLoading = false,
                                isSending = false,
                                error = "Error al enviar mensaje: ${result.message}"
                            )
                        }
                    }
                    else -> {
                        Timber.d("Resultado no manejado: $result")
                    }
                }
            } catch (e: Exception) {
                Timber.e(e, "Error al enviar mensaje")
                
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        isSending = false,
                        error = "Error al enviar mensaje: ${e.message}"
                    )
                }
            }
        }
    }
    
    /**
     * Limpia el error actual
     */
    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
} 